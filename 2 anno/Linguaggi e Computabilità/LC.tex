\documentclass[11pt]{article}

\usepackage{tikz}
\usetikzlibrary{arrows}

\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  arn_n/.style = {treenode, circle, blue, font=\sffamily\bfseries, draw=blue,
    fill=white, text width=1.5em},% arbre rouge noir, noeud noir
  arn_r/.style = {treenode, circle, red, draw=red, 
    text width=1.5em, very thick},% arbre rouge noir, noeud rouge
}


\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{graphicx}


\title{Linguaggi e Computabilità}
\author{Daniele De Micheli}
\date{2019}

\renewcommand*\contentsname{\textit{Indice}}


%presettaggio per teoremi e assiomi/definizioni%

\newtheorem*{problemaDecisione}{Problema di Decisione}
\newtheorem*{problemaMembership}{Problema di Membership}
\newtheorem*{relazioneNorm}{Prima relazione}
\newtheorem*{relazioneStar}{Seconda relazione}
\newtheorem*{alberoSintattico}{Albero Sintattico}



%fine%

\begin{document}

\maketitle
\tableofcontents
\part{Prima Parte}
\section{Alfabeti e Linguaggi}
Si definisce \textbf{alfabeto} un insieme finito e non vuoto di simboli. Ad esempio, l'alfabeto $\{A,B,C,...,Z\}$ potremmo definirlo come l'insieme delle lettere maiuscole dell'alfabeto italiano. Altri esempi intuitivi sono l'inseme delle cifre che compongono i numeri arabi $\{1,2,3,...9,0\}$ o l'insieme $\{0,1\}$ che rappresenta i numeri binari. Un alfabeto si indica con una lettera maiuscola
greca:
\begin{itemize}
	\item $A=\{A,B,C,...,Z\}$;
	\item $\Gamma = \{0,1\}$;
\end{itemize}
Si definisce invece una \textbf{stringa} un insieme vuoto, finito o infinito di simboli presi da un dato alfabeto. Una stringa vuota si indica con $\epsilon o \lambda$.
\subsection{Stringhe}
Una stringa, come abbiamo già visto, si rappresenta con una lettera greca
maiuscola. Nel caso volessimo indicare invece la lunghezza di una stringa
bisogna utilizzare la seguente notazione: $$|\Gamma | = x$$ dove $\Gamma$ rappresenta la stringa e x la sua lunghezza.
\\ \\
Le stringhe possono inoltre essere "manipolate", o meglio esse si possono \textit{concatenare} per ottenere una nuova stringa. Tale operazione si può indicare così: $\Gamma \circ A$ e si legge "$\Gamma \medspace concatenata \medspace ad \medspace A$". La concatenazione \textbf{non} è un'operazione commutativa. Infatti $$\Gamma \circ A \neq A \circ \Gamma$$

Se prendiamo ad esempio $A = \{010\}$ e $\Gamma = \{11\}$, allora $A \circ \Gamma = \{01011\}$ mentre $\Gamma \circ A = \{11010\}$ che non sono assolutamente uguali come si può ben vedere.

\subsection{Alfabeti}
Gli alfabeti, come abbiamo già visto, sono insieme finiti di simboli. Su tali
insiemi  è possibile definire delle operazioni che generano delle stringhe a
partire dall'alfabeto stesso.

\paragraph{Potenza di un alfabeto}: dato un alfabeto $E$, si definisce \textit{potenza di E} la stringa di lunghezza k contenente tutti gli elementi dell'alfabeto $E$.
$$dato \medspace E, k \geq 0 \in \mathbb{Z}, \Rightarrow E^k = E\times E\times E\times E \times ... \times E, k \medspace volte$$

Se $|E| = q$, allora $|E^k| = q^k$. Ad esempio, prendiamo l'alfabeto $E=\{0,1\}$. Allora:
\begin{itemize}
	\item $E^1 = \{0,1\}$
	\item $E^2 = \{00,01,10,11\}$
	\item $E^3 = \{000,001,010,011,100,101,110,111\}$
\end{itemize}
Come si può intuire dall'esempio qui sopra, il risultato della potenza di un alfabeto non è altro che l'insieme delle \textit{combinazioni} di numero k degli elementi dell'alfabeto.

\paragraph{Chiusura di Kleene}: la chiusura di Kleene è un'operazione che riguarda
le potenze di un alfabeto. Infatti tale operazione non è altro che l'unione di
tutte le potenze di un alfabeto fino a k. Formalmente: $$E^{\star} = \cup E^k = E^0 \cup E^1 \cup E^2 ... \cup E^k, \medspace t.c. \medspace k\geq 0$$

Un'operazione derivata da quest'ultima è la chiusura di Kleene ma senza l'elemento 0: $$E^{+}=E^{\star}\setminus E^0$$

\subsection{Linguaggio} possiamo definire un \textit{linguaggio} $L \medspace su \medspace E$ un sottoinsieme di $E^{\star}$ tale che $L \subseteq E^{\star}$. Per esempio, preso $E = \{a,b,c\}$, un linguaggio L potrebbe essere $L_{1}=\{aa,cbc\}$. Un linguaggio può essere finito (vedi $L_ {1}$), oppure infiniti (es. $L_{2} = \{ w \in E^{\star} \thickspace | \thickspace w \medspace contiene \medspace lo \medspace stesso \medspace numero \medspace di \medspace a \medspace e \medspace c\}$).
\\ \\
Preso un linguaggio $L \subseteq E^{\star}$, possiamo affermare che:
\begin{itemize}
\item[1.] $ \emptyset \subseteq L$;
\item[2.] $ \varepsilon \subseteq L $;
\item[3.] $ E^{\star} \subseteq L$;
\end{itemize}
sono tutti linguaggi. La principale caratteristica di un linguaggio è che esso deve essere riconosciuto e interpretato da una macchina (o automa) ed essa deve anche essere in grado di generarlo tramite una \textbf{\textit{grammatica}}.
\begin{problemaDecisione}
Il problema di decisione si presenta nel momento in cui, dato un quesito, le possibili risposte sono sempre e sole "sì" o "no".
\end{problemaDecisione}
\begin{problemaMembership}
Il problema di Memebership è legato al concetto di stringa (come input), di linguaggio e di appartenenza ad un determinato linguaggio. Data una stringa w in input, una determinata macchina deve essere in grado di dire se essa appartiene ad un linguaggio oppure no.
\end{problemaMembership}

\textbf{\textit{DEFINIZIONI}}
Una \textbf{forma sentenziale} è una stringa di simboli terminali e non terminali: $\gamma \in (V \cup T)^{\star}$

\paragraph{Concatenazione di linguaggi}: Dati due linguaggi $L_1, L_2 \subseteq E^{\star}$ allora $$L_1 \circ L_2 = \{ w | w = w_1 \circ w_2, w_1 \in L_1, w_2 \in L_2\} $$

\subsection{Grammatica context-free -CFG-}
Una grammatica context free è una grammatica che non prevede l'incrocio dei simboli terminali per cui è necessario utilizzare delle regole differenti. Un esempio di linguaggio context free è il seguente:
\\ \\
\paragraph{Stringhe palindrome}: le stringhe palindrome sono un esempio semplice di linguaggio che utilizza una grammatica context-free.
Abbiamo il l'alfabeto $E = \{0,1\}$ e il linguaggio costruito su esso $L_{pal} \subseteq E^{\star}$. Da questo alfabeto e con questo linguaggio possiamo costruire una stringa w palondroma come $$w = \{0110\}$$
Essa può essere definita per induzione come segue:
\begin{enumerate}
\item Passo base: $\varepsilon , 0, 1 \in L_{pal}$
\item Passo induttivo: se $w \in L_{pal}$, allora $0w0, 1w1, \varepsilon \in L_{pal}$
\end{enumerate}
Un esempio di regole del linguaggio possono essere:
\begin{equation}
\begin{split}
\color{red}S \color{black} \rightarrow \color{blue}\varepsilon\color{black}\\&\\
\color{red}S \color{black} \rightarrow \color{blue}0 \color{black}\\&\\
\color{red}S \color{black} \rightarrow \color{blue}1 \color{black}\\&\\ 
\color{red}S \color{black} \rightarrow \color{blue}0S0 \color{black}\\&\\
\color{red}S \color{black} \rightarrow \color{blue}1S1\color{black}
\end{split}
\end{equation}
in cui la \color{red} \textbf{testa} \color{black} può essere sostituita dal \color{blue} \textbf{corpo}\color{black}.
\\ \\
Queste regole possono essere applicate tramite le due \emph{relazioni}:
\begin{enumerate}
\item $\Rightarrow$
\item $\Rightarrow^{\star}$
\end{enumerate}
La prima (1) possiamo definirla come segue:
\begin{relazioneNorm}
Sia $G=(V, T,P,S)$ una CFG e sia $\alpha A \beta$ tale che $\alpha,\beta \in (V\cup T)^{\star}$ e $A \in V$. Sia $A \rightarrow \gamma \in P$. Allora $\alpha A\beta \Rightarrow \alpha \gamma \beta$.
\end{relazioneNorm}
\begin{relazioneStar}
Si ha che $\alpha \Rightarrow^{\star} \beta$, con $\alpha, \beta \in (V \cup T)^{\star}$, se e solo se $\exists \medspace \gamma_{1}, \gamma_{2}, ... ,\gamma_{n} \in (V\cup T)^{\star}$ tale che $\alpha \Rightarrow \gamma_{1} \Rightarrow \gamma_{2} \Rightarrow \gamma_{3} \Rightarrow ... \Rightarrow \gamma_{n} \Rightarrow \beta$ con $n \geq 1$.
Se n = 1, allora $\alpha = \beta$ e vale $\alpha \Rightarrow^{\star} \beta$ cioè $\alpha \Rightarrow^{\star} \gamma$.
\end{relazioneStar}
\subsection{Grammatica NON context-free}
Il linguaggio di esempio (di tipo 2): $L = \{w \in \{a,b,c\}^{\star} | w = a^nb^nc^n, n\geq 1\}$
è generato dalla seguente grammatica (NON context-free): $$ G=(\{S,X,B,C\}, \{a,b,c\}, P, S)$$
e dove le regole di produzione sono:
\begin{enumerate}
	\item $S \rightarrow aSBC$
	\item $S \rightarrow aBC$
	\item $CB \rightarrow XB$
	\item $XB \rightarrow XC$
	\item $XC \rightarrow BC$
	\item $aB \rightarrow ab$
	\item $bB \rightarrow bb$
	\item $bC \rightarrow bc$
	\item $cC \rightarrow cc$
\end{enumerate}
Le grammatiche 3,4,5 possono essere "collassate" in $CB \rightarrow BC$
Si può dimostrare , usando il Pumping Lemma per i CFL, che non è context-free.
\\ \\
Esempio di Derivazione:
\\ \\
Deriviamo la stringa abc (corrispondente a n = 1), indicando anche ad ogni passo la regola usata.
$$ S (2)\rightarrow aBC (6)\rightarrow abC (8)\rightarrow abc$$
Deriviamo la stringa aabbcc (corrispondente a n = 1), indicando anche ad ogni passo la regola usata.

\begin{equation*}\label{stigeiz}\begin{split}
S (1)\rightarrow aSBC (2)\rightarrow aaBCBC (3)\rightarrow aaBXBC (4) \rightarrow aaBXCC (5) \rightarrow \\&\\ \rightarrow aaBBCC (6)\rightarrow aabBCC (7)\rightarrow aabbCC (8)\rightarrow aabbcC (9)\rightarrow aabbcc
\end{split}
\end{equation*}

In generale, per derivare $a^nb^nc^n$, per n $<$ 1:

\begin{equation*}
\begin{split}
S(n-1 \medspace volte \rightarrow (1)) a^{n-1}S(BC)^{n-1}\rightarrow (2) a^n(BC)^n(n(n-1)/2 \medspace volte \medspace la \\&\\ sequenza \rightarrow (3), \rightarrow (4), \rightarrow (5))a^nB^nC^n....slide
\end{split}
\end{equation*}

Esercizio: creo una CFG su $L = \{a^{n+m}xc^nyd^m, \medspace con n,m \geq 0\}$:


\section{Alberi Sintattici}
Un albero sintattico è una rappresentazione grafica (ad albero) che mostra come una forma sentenziale o una stringa è stata ottenuta tramite le regole di derivazione.

\begin{alberoSintattico}
Data una CFG definita come $$G=(V,T,P,S)$$ l'albero sintattico è un albero tale che
\begin{enumerate}
	\item Ogni nodo interno è \textbf{etichettato} da una variabile;
	\item Ogni foglia è etichettata da una variabile, oppure un simbolo terminale o ancora da $\varepsilon$. Se è etichettata con $\varepsilon$ allora è l'unico figlio riscontrato.
	\item Se un nodo è etichettato con A (variabile) e i rispettivi figli sono etichettati da sinistra verso destra con $X_1,X_2,X_3,...,X_k$, allora $A \rightarrow X_1,X_2,X_3,...,X_k \in P$ (ovvero A è una produzione della grammatica).
\end{enumerate}
\end{alberoSintattico}

Un esempio pratico di albero sintattico: data la CFG definita come
\begin{equation}
E \rightarrow I\medspace |\medspace E+ E\medspace |\medspace E*E\medspace |\medspace (E)\medspace \medspace e \medspace \medspace I \rightarrow a\medspace |\medspace b \medspace |\medspace Ia\medspace |\medspace I0\medspace |\medspace I1
\end{equation}


\begin{center}
%%creazione dell'albero secondo la CFG data
\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2cm/#1,
  level distance = 1.5cm}] 
\node [arn_n] {E}
    child{ node [arn_n] {E} 
            child{ node [arn_r] {I}}            
    }
    child{ node [arn_r] {+}
  	}
  	child{	node[arn_r] {E}
  	}
; 
\end{tikzpicture}
\end{center}
abbiamo che l'albero sintattico ottenuto è un albero \textbf{radicato} e \textbf{ordinato}. Si può notare che i \color{blue}nodi interni \color{black} rappresentano i passaggi per arrivare alle \color{red}foglie\color{black}. Difatti è possibile ricostruire il processo di derivazione: $$E \rightarrow E \medspace + \medspace E \rightarrow I \medspace + \medspace E$$

\end{document}
