\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{fourier} %per il simbolo di Attenzione!
\usepackage{multirow} % Required for multirows

\title{Linguaggi di Programmazione}
\author{Daniele De Micheli}
\date{2019}

\renewcommand*\contentsname{\textit{Indice}}

%presettaggio per teoremi e assiomi/definizioni%

\newtheorem{horn}{Clausole di Horn}
\newtheorem*{isoscele}{Teorema del triangolo isoscele}


%fine%

\begin{document}

\maketitle
\tableofcontents

\part{Introduzione alla logica}
\section{Logica e Ragionamento}
Per poter iniziare a parlare di \textit{linguaggi logici}, dobbiamo prima acquisire cosa è un \textit{linguaggio}.
Dobbiamo quindi capire come un \color{red} ragionamento \color{black} può essere \color{red} formalizzato \color{black} in un numero di \color{red} passi \color{black} (connessi da \color{red} regole \color{black}) a partire da \color{red} premesse \color{black} per raggiungere una \color{red} conclusione \color{black}. 

Questo processo è quello che siamo abituati a riscontrare nella soluzione di \textit{teoremi} tramite \textbf{dimostrazioni}.

Un esempio di applicazione di questo processo possiamo vederlo qui di seguito: 

\begin{isoscele}
Dato un triangolo isoscele, ovvero con due lati $AB = BC$, si dimostra che gli angoli $\angle A$ e $\angle C$ sono uguali.
\end{isoscele}

\textit{\textbf{Conoscenze pregresse}}
\begin{enumerate}
	\item Se due triangoli sono uguali, i due triangoli hanno lati e angoli uguali.
	\item Se due triangoli hanno due lati e l'angolo sotteso uguali, allora i due triangoli sono uguali.
	\item BH bisettrice di $\angle B$ cioè $\angle ABH = \angle HBC$.
\end{enumerate}

\textit{\textbf{Dimostrazione}}
\begin{itemize}
	\item $AB = BC$ per ipotesi;
	\item $\angle ABH = \angle HBC$ per (3);
	\item Il triangolo $HBC$ è uguale al triangolo $ABH$ per (2);
	\item $\angle A \medspace e \medspace \angle C$ per (1); 
\end{itemize}
Quindi abbiamo trasformato (2) in "\textbf{Se} $AB = BC$ e $BH = BH$ e $\angle ABH = \angle HBC$, \textbf{allora} il triangolo $ABH $ è uguale al triangolo $HBC$" e abbiamo trasformato (1) in "\textbf{Se} triangolo $ABH$ è uguale al triangolo $HBC$, \textbf{allora} $AB = BC $ e $ BH = BH $ e $AH = HC $ e $\angle ABH = \angle HBC $ e $\angle AHB = \angle CHB$ e $\angle A = \angle C$".

L'obiettivo diventa a questo punto formalizzare e razionalizzare il processo che permette di affermare $$ AB=BC\vdash\angle A = \angle C$$ dove $\vdash$ indica il simbolo di \color{red} \textit{derivazione logica} \color{black}, che comunemente significa "\textbf{consegue}", "\textbf{allora}", ecc.
\\ \\
\textit{\textbf{Formalizzazione}}
\\ \\
Abbiamo assunto che:
\begin{itemize}
\item $\textbf{P} = \{AB=BC, \angle ABH = \angle HBC, BH = HB\}$.
\end{itemize}
Avevamo inoltre delle conoscenze pregresse (vedi \textit{conoscenze pregresse} sopra riportate).
Abbiamo quindi costruito una catena di \textbf{formule}:
\begin{table}[ht]
  \begin{center}
    \caption{Triangolo Isoscele.}
    \label{tab:isoscele}
    \begin{tabular}{l|l}
      \textbf{Formule} & \textbf{Origine} \\
      \hline
      \multirow{2}{*}{P1:$AB=BC$} 	& da \textbf{P} \\ % <-- Combining 2 rows with arbitrary with (*) and content 12
      								& 10.1 \\ % <-- Content of first column omitted.
      \hline
      P2: $\angle ABH = \angle HBC$  & da \textbf{P} \\
      \hline
      P3: $BH = HB$ &  da \textbf{P}  \\
      \hline
      \multirow{2}{*}{P4:$AB = BC \wedge BH = HB \wedge \angle ABH = \angle HBC$ } 	& da \textbf{P1}, \textbf{P2}, \textbf{P3} e \\ % <-- Combining 2 rows with arbitrary with (*) and content 12
      																				& \color{red} introduzione della congiunzione \color{black} \\
      \hline
      P5: $\bigtriangleup ABH = \bigtriangleup HBC$ & da \textbf{P4}, $regola_{1}$ e \color{red} Modus Ponens \color{black} \\ 
      \hline
      P6:$AB = BC \bigwedge BH = BH \bigwedge AH =HC $ \\ $\medspace \medspace \bigwedge \angle ABH = \angle HBC \bigwedge \angle AHB = \angle CHB \bigwedge $ \\ $\medspace \medspace  \angle A = \angle C$	& da \textbf{P5}, $regola_2$  e \color{red} Modus Ponens \color{black}  \\
      \hline
      \multirow{2}{*}{P7: $\angle A = \angle C$} & da \textbf{P6} e l'\color{red}eliminazione della \\ &\color{red} congiunzione\color{black} (il simbolo $\bigwedge$)
    \end{tabular}
  \end{center}
\end{table}\textbf{•}
\\ \\
Le parti evidenziate in rosso nella tabella \ref{tab:isoscele} sono le \emph{regole di inferenza}.

\subsection{Processo di dimostrazione}
Una "prova" D, dove \color{red}\textbf{S} \color{black} è l'insieme delle \textit{"affermazioni note"} e \textbf{F} la frase (es. la formula) che vogliamo provare.
\begin{equation*}
D\equiv \color{red}\textbf{S}\color{black} \vdash F
\end{equation*} 
(che si legge: \textbf{F} è una conseguenza di \color{red}\textbf{S}\color{black}) è una sequenza di passi $$D = < P_1, P_2, ... , P_n >$$ dove 

$$P_n = F$$  
$$P_i \in S \cup \{P_j \medspace | \medspace j < i\}$$
o $P_i$ può essere ottenuto da $P_{i1},...,P_{im}$ (con $i1 < i, ... , im < i$)mediante l'applicazione di una regola di inferenza.

\subsection{Regole di inferenza e calcoli logici}
Un insieme di regole di inferenza costituisce la base di un calcolo logico. Diversi insieme di regole danno vita a diversi calcoli logici. Lo scopo di un calcolo logico è quello di manipolare delle formule logiche in modo completamente \textbf{sintattico} al fine di stabilire una
connessione tra un insieme di formule di \textit{partenza} (di solito un
insieme di formule dette \emph{assiomi}) ed un insieme di \textit{conclusioni}.

\section{Programmazione Logica}
La programmazione logica nasce all'inizio degli anni settanta da
studi sulla deduzione automatica: il \textit{\textbf{Prolog}} costituisce uno dei
sui risultati principali. Essa non è soltanto rappresentata dal Prolog; costituisce infatti un settore molto ricco che cerca
di utilizzare la logica matematica come base dei linguaggi di
programmazione.
\\ \\ 
Gli obiettivi del linguaggio di programmazione logica sono:
\begin{itemize}
	\item semplicità del formalismo;
	\item linguaggio ad alto livello;
	\item semantica chiara;
\end{itemize}
Questo tipo di linguaggio si focalizza sulle solide basi della \textit{logica matematica}. Con l'avvento dell'informatica difatti si è sempre più utilizzata la logica matematica per dimostrare teoremi tramite i calcolatori (che permettono di ottenere risultati in minor tempo e con meno errori). Tra le procedure utilizzate si ricordano la \textit{procedura di Davis e Putnam} e il \textit{principio di risoluzione}. 

Per rendere bene l'idea, la programmazione logica viene utilizzata per verificare la correttezza di altri software, per rappresentare la conoscenza di Intelligenza Artificiale o ancora per il formalismo nei database (come Datalog).

\subsection{Stile dichiarativo della programmazione logica}
Lo stile della programmazione logica ha delle precise caratteristiche:
\begin{itemize}
 	\item[$\circ$] Un programma è un \textit{insieme di formule}.
 	\item[$\circ$] Possiede un grande potere espressivo.
 	\item[$\circ$] Il processo di risoluzione prevede la costruzione di una dimostrazione logica di un'affermazione (\textbf{goal}).
 	\item[$\circ$] Possiede una \color{red}base formale\color{black}:
 	\begin{itemize}
 		\item[--] Calcolo dei predicati del primo ordine (vedi sez. ????) ma con limitazione nel tipo di formule (\textbf{\emph{clausole di Horn}} (\ref{thm:horn}))
 		\item[--] Utilizzo di particolari tecniche per la dimostrazione di teoremi (meccanismo di \textbf{\emph{Risoluzione}})
 	\end{itemize}
\end{itemize}

\subsection{PROLOG}
Il Prolog (acronimo di \textbf{PRO}gramming in \textbf{LOG}ic) fu ideato e realizzato nel 1973 da Robert Kowalski (aspetto teorico) e Marten Van Emdem (dimostrazione sperimentale) . Esso si basa su una restrizione della \textit{logica del primo ordine}. Come caratteristica base dei linguaggi logici, anche Prolog utilizza uno stile dichiarativo di programmazione. La sua primaria funzione è quella di determinare se una certa affermazione è vera oppure no e, se è vera, quali vincoli sui valori attribuiti alle variabili hanno generato la risposta.


\paragraph{Formule ben formate} Le formule ben formate (\textit{fbf}, o \textbf{well-formed formula}, \textit{wff}) di un linguaggio logico del primo ordine può essere riscritta in \color{red}forma normale a clausole\color{black}.

Vi sono due forme normali a clausole:
\begin{itemize}
	\item[$\circ$]\color{blue}Forma normale congiunta\color{black} (conjunctive normal form - CNF): la formula è una \textbf{congiunzione} di \textbf{disgiunzioni} di predicati o di negazioni di predicati (letterali \textit{positivi} o letterali \textit{negativi}).
	\begin{equation}
	\label{eqz:CNF}
	\bigwedge_i \bigg( \bigvee_j L_{ji} \bigg) 
	\end{equation}
	\item[$\circ$]\color{blue}Forma normale disgiunta\color{black} (disjunctive normal form - DNF): la formula è una \textbf{disgiunzione} di \textbf{congiunzioni} di predicati o di negazione di predicati (letterali \textit{positivi} o letterali \textit{negativi}).
	\begin{equation}
	\bigvee_j \bigg( \bigwedge_i L_{ji} \bigg) 
	\end{equation}
\end{itemize}
dove 
\begin{equation*}
	L_{ij} \equiv P_{ij} (x,y,...,z) \circ L_{ij} \equiv \neg Q_{ij}(x,y,...,z)
\end{equation*}

\subsubsection{Forma Normale Congiuntiva}
Consideriamo una \textit{wff} in CNF (\ref{eqz:CNF}). Per esempio:
\begin{equation}
\label{eqz:es1CNF}
\underbrace{(p(x) \vee q(x,y) \vee \neg t(z))}_{clausola \medspace 1} \color{red}\wedge\color{black} \underbrace{(p(w) \vee \neg s(u) \vee \neg r(v)}_{clausola \medspace 2})
\end{equation}
se scartiamo il simbolo di \color{red}congiunzione \color{black}  (\ref{eqz:es1CNF}), rimaniamo con solo le clausole disgiuntive
\begin{enumerate}
	\item $(p(x) \vee q(x,y) \vee \neg t(z))$
	\item $(p(w) \vee \neg s(u) \vee \neg r(v))$
\end{enumerate}
Le clausole così ottenute sono anche riscrivibili come
\begin{enumerate}
	\item $t(z) \Rightarrow p(x) \vee q(x,y)$ 
	\item $s(u) \wedge r(v) \Rightarrow p(w)$
\end{enumerate}
ovvero un insieme di formule in CNF è riscrivibile come un insieme (congiunzione) di implicazioni.

\begin{horn}
\label{thm:horn}
Le clausole che hanno al più un solo letterale positivo (con o senza letterali negativi) prendono il nome di \textbf{\emph{Clausole di Horn}}.
\end{horn}
Detto questo, abbiamo che:
\begin{itemize}
	\item Non tutte le fbf possono essere trasformate in un insieme di clausole di Horn.
	\item \textit{I programmi Prolog sono collezioni di clausole di Horn}
\end{itemize}

\subsubsection{Struttura del Prolog}
Il linguaggio Prolog:
\begin{itemize}
	\item[$\circ$]Non contiene (quasi) istruzioni
	\item[$\circ$]Contiene solo fatti e regole (clausole di Horn):
	\begin{itemize}
		\item \textbf{Fatti}: asserzioni vere nel contesto che stiamo descrivendo.
		\item \textbf{Regole}: ci danno gli strumenti per dedurre nuovi fatti da quelli esistenti.
	\end{itemize}
	\item[$\circ$]Un programma Prolog ci dà informazioni su un sistema ed è normalmente chiamato \color{red}base di conoscenza \color{black}(\color{red}knowledge base\color{black})
	\item[$\circ$]Un programma Prolog non si "esegue" ma si \textit{"interroga"} (\textbf{queried}): al programma si chiede se i fatti sono veri; esso risponderà son un \color{blue}True \color{black} o \color{blue}False \color{black} alla domanda.
\end{itemize}

\subsubsection{Sintassi del Prolog}
Un programma Prolog è costituito da un insieme di clausole della forma


\begin{table}[ht] %ht indica di creare la tabella dove la metti, sempre che sia possibile.
	\begin{center}
	\caption{Sintassi Prolog}
	\label{sintassiProlog}
	\begin{tabular}{l|l}

	$a.$ & \color{red}FATTO / ASSERZIONE\color{black} \\
	\hline
	$c :- \medspace b_1 , b_2 , _ , b_n . $ & \color{red}REGOLA\color{black} \\
	\\ \\

	$:- \medspace q_1 , q_2 , ... , q_m $ & \color{red}GOAL\color{black} \\
	\hline
	$?-\medspace q_1 , q_2 , ... , q_m $ & \color{red}QUERY\color{black} \\
	
	
	\end{tabular}
	\end{center}
\end{table}
In cui $a, b_i \medspace e \medspace  q_i $ sono \emph{\textbf{termini}} (compositi). 
Da notare che in molte implementazioni il prompt Prolog è un operatore che chiede al sistema di valutare il \textbf{goal}, in questo caso una congiunzione di termini. 
\paragraph{Termini} Le espressioni nel Prolog sono chiamate \color{red}\textbf{termini}\color{black}. Esistono diversi tipi di termini:
\begin{itemize}
	\item[$\circ$]ATOMI :
	\begin{itemize}
	
	\item Una sequenza di caratteri alfanumerici, che inizia con un carattere minuscolo (può contenere il carattere $"_"$ underscore)
	\item Qualsiasi cosa racchiusa tra apici singoli (' ')
	\item Un numero
	\item Una stringa (SWI Prolog)
\end{itemize}
	\item[$\circ$]VARIABILI:
	\begin{itemize}
	
	\item Una variabile (logica) è una sequenza alfanumerica che inizia con un carattere \textbf{MAIUSCOLO} o con il carattere $\_$ (underscore)
	\item Le variabili (notare il plurale) composte solo dal simbolo $\_$ sono chiamate \textbf{indifferenza} (\textit{don’t care o any}) o \textbf{anonime}
	\item Le variabili vengono \textbf{istanziate} (legate a un valore) con il
procedere del programma (nella dimostrazione del teorema)
\end{itemize}
	\item[$\circ$]Una composizione di termini $\Rightarrow$ TERMINE COMPOSTO (simbolo di \color{red}\textit{funtore} \color{black} più uno o due argomenti):
	\begin{itemize}
		\item[+] Un \textbf{funtore} (simbolo di funzione o di predicato definito come atomo)
		\item[+] Una sequenza di termini racchiusi tra parentesi tonde e
separati da virgole. Questi sono chiamati argomenti del funtore
	\end{itemize}
	
\end{itemize}
%\danger \leaders\vrule height 2.5pt depth -1.5pt \hfill \null
%\\ \\
\danger\medspace\danger \hfill \danger\medspace\danger
\\ \\
\textbf{\emph{Non ci deve mai essere uno spazio tra il funtore e la parentesi di
sinistra}}; questo per via di caratteristiche molto sofisticate del
sistema di parsing di Prolog (cfr., operatori)
\\ \\
\danger\medspace\danger \hfill \danger\medspace\danger
\\ \\
\paragraph{Prolog: fatti e predicati}

Un \textbf{fatto} (\textbf{predicato}) consiste in:
\begin{itemize}
	\item Un nome di predicato, ad esempio \textit{fattoriale}, \textit{genitore}, \textit{uomo} o \textit{animale}; deve iniziare con una lettera \color{red} minuscola\color{black}.
	\item Zero o più argomenti come \textit{maria}, \textit{42} o \textit{cane}. Da tenere presente che i fatti (e le regole e le domande) \textbf{devono} essere terminati da un punto (".").
\end{itemize}

\paragraph{Le regole} In Prolog si usano le \textbf{regole} quando si vuole esprimere che un certo fatto dipende da un insieme di altri fatti. Per esprimere in linguaggio naturale questa dipendenza usiamo la parola "\color{blue}se\color{black}" ("if" in inglese).

Ad esempio:
\begin{itemize}
	\item \textit{Uso l'ombrello \textbf{se} piove};
	\item \textit{Luca mangia la pizza \textbf{se} non contiene glutine};
\end{itemize}
Le regole sono anche usate per esprimere definizioni. Ad esempio:
\subparagraph{X è un pesce \textbf{se}:}
\begin{itemize}
	\item X è un animale
	\item X ha le squame
\end{itemize}
Una regola è costituita da una \color{blue}\textbf{testa }\color{black} e da un \color{blue}\textbf{corpo}\color{black}. Sono inoltre caratterizzati come segue:
\begin{enumerate}
	\item Testa e corpo sono collegati dalloperatore "$:-$".
	\item La testa di una regola corrisponde al \color{red}\textbf{conseguente} \color{black} di un'implicazione logica. 
	\item Il corpo di una regola corrisponde all’\color{red}\textbf{antecendente} \color{black} di un’implicazione logica.
	\item Le regole Prolog corrispondono alle \color{blue}\textbf{clausole di Horn} \color{black}, ovvero hanno un solo termine (predicato) come conseguente.
	\begin{itemize}
		\item[$\circ$] L'operatore Prolog '$:-$' esprime il "\textbf{se}" (\textit{implicazione}).
		\item[$\circ$] L'operatore Prolog ',' equivale a "\textbf{e}" (\textbf{\textit{and}}, o \textit{congiunzione}).
	\end{itemize}
\end{enumerate}
Un esempio di regola Prolog può essere:
\\ \\
\textit{"un pesce è un animale che ha le squame"} diventa:
\begin{flalign}
& pesce(X) \medspace :- \medspace animale(X), \medspace ha\_ le\_ squame(X). && \nonumber 
\end{flalign}
Una relazione può essere però definita per necessità da due regole (o clausole) aventi lo stesso predicato come conclusione. Per esempio:
\begin{flalign*}
&genitore(X, Y) \medspace :- \medspace padre(x, Y). && \\\nonumber
&genitore(X, Y) \medspace :- \medspace madre(x, Y). &&
\end{flalign*}
Le regole (ed i fatti) sono implicitamente connesse dall'operatore logico di congiunzione ("\color{red}and\color{black}"); se non si sono commessi errori logici, \textbf{entrambe} le implicazioni soprastanti sono da ritenersi \textbf{vere}.
\\ \\
Una relazione può essere definita anche \emph{ricorsivamente}. In questo caso la definizione richiede almeno due proposizioni: una è quella ricorsiva che corrisponde al caso generale, l'altra esprime il caso base più semplice.

\begin{flalign*}
&antenato(X, Y) \medspace :- \medspace genitore(X,Y). &&\\\nonumber
&antenato(X, Y) \medspace :- \medspace genitore(Z,Y), antenato(X, Z).&&
\end{flalign*}

\subparagraph{Operatori Logici}: gli operatori logici "and" e "or" possono essere utilizzati nelle regole tramite una specifica sintassi.
L'operatore "\textbf{AND}" viene inserito in una regola con il carattere \textit{virgola} ',';
L'operatore "\textbf{OR}" viene inserito in una regola con il carattere  \textit{punto e virgola} ';'.

\subparagraph{RICAPITOLANDO} Bisogna ricordare che:
\begin{enumerate}
	\item ogni fatto o regola DEVE terminare con un punto '.'
	\item ogni variabile DEVE iniziare con una MAIUSCOLA
	\item i commenti si inseriscono dopo un "\%" (commento in linea) o tra '/*' e '*/' (come in altri linguaggi).
\end{enumerate}

\subsection{L'interprete Prolog: interrogazioni}
Una volta che le regole e i fatti sono stati "caricati" nell'interprete, eseguire un programma Prolog equivale a \textit{interrogare} l'\textbf{interprete}. Una volta fatto partire, l'interprete Prolog ci presenta un prompt così:
\begin{flalign*}
& ?- &&\nonumber
\end{flalign*}
Come si può intuire anche dalla sintassi del prompt, interrogare l'interprete non è altro che porre una \textit{domanda} a cui generlamente il Prolog risponde "\textbf{true}" o "\textbf{false}".
Le interrogazioni possono contenere variabili interpretate come \emph{\textbf{variabili esistenziali}}. Queste sono istanziate quando il Prolog prova a rispondere alla domanda fattagli. Tutte le variabili istanziate vengono mostrate nella risposta insieme a "true".
%\danger \leaders\vrule height 2.5pt depth -1.5pt \hfill \null


\end{document}
